"""
    n = 3이고 w = [ 10, 20, 30] 일때 최대 중량을 구하려면
    i) 모든 로프를 다 사용할때
        w 리스트 중 제일 작은 원소값이 기준으로 양쪽이 골고루 분산되어 최대 30을 버틸수 있다.
        (최소 중량) X (병렬로 사용된 로프 수)
    ii) 최소 중량인 10을 제외한 로프를 사용했을때
        20 x (2) = 40     
    iii) 최소 중량이 10과 20을 제외한 로프를 사용했을때
        30 x (1) = 30
    >> 최대는 40 
"""

# 로프의 갯수를 전달받는다.
n = int(input())

# 한개의 로프가 견딜 수 있는 중량 정보를 담는 리스트
rope = []
# 특정 무게 w를 n개의 로프로 병렬적으로 들어올릴때 최대 중량을 담는 리스트
# val은 0번 인덱스를 무시하고 1번 인덱스부터 진행된다.
# val 1번 인덱스는 모든 로프를 사용했을때 최대 중량을 담는다.
# val 2번 인덱스는 모든 로프에서 한개 제외(최소 중량을 견디는 로프)하고 사용했을때 최대 중량을 담는다.
# ... 점진적으로
# val n번까지 한개의 로프를 사용했을때 최대 중량 정보를 담는다.
val = [0] * (n+1)

# 인풋 받는 코드
for i in range(n):
    w = int(input())
    rope.append(w)

# 정렬을 시켜서 0번째 인데스가 제일 작은 값으로 배치되게 정렬한다.
rope = sorted(rope)

for  i in range(1,n+1):
    length = (len(rope) - (i-1))
    val[i] = rope[i-1] * length

print(max(val))