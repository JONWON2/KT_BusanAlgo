
'오탈자가 1개만 존재한다!!!'

문자열에서 오탈자가 존재할 수 밖에 없는 영역이 나오면

뒤에 있는 건 고려하지 않는다. 뒤에건 오탈자가 없어야 하므로..

이 문제 자체가 '전제조건'을 '!특히!' 고려해줘야한다!!!

우선 여는괄호 '(' = +1, 닫는 괄호 ')' = -1로 두고, 괄호문자열을 리스트로 받는다.

그 리스트를 for문으로 돌면서 total값도 구해준다.

이 문제의 조건은 최대 1개의 오타가 존재하는 것이므로,

최종 total 값이, 닫는괄호 ')'가 오탈자면 '-2'이거나 여는괄호 '('가 오탈자면 '+2'이다. 

-------------------------------------------------------------------

닫는괄호 ')'가 오탈자인 경우를 고려해보자.
최종 total이 -2가 나온다.

하지만, 최종 total까지 안가도
total이 -1 이 되는 순간이 닫는괄호 ')'가 오탈자라는 것의 기준이다. 

예시를 보고 이해해보자.

예시 1.
( ) ) ) -> total : +1, 0, -1, -2
( ) ) / ')' : +1, 0, -1 /

total이 -1이 나오고 나서 /

그 다음은 무조건 ')' 이 되야한다.
-> 오탈자는 하나여야한다는 전제조건
-> total이 -1이 나오고나서 '(' 이게 나오면 오탈자가 2개다!!

즉, total =-1 이 기준점이라 생각가능ㅎㅎ

다시 말하면, total = -1이 나온 순간까지의 닫는괄호 ')'의 개수가

수정할 수 있는 오탈자 ')' 경우의 수가 된다. <이 문제에서는> = 2


예시 2.
직관적 이해를 도울 수 있는 다른 예시를 들어보겠다.

( ) ) ( ) ) -> total : +1, 0, -1, 0, -1, -2

( ) ) / '( ) )' : +1, 0, -1 /

total = -1이 되는 순간까지의 닫는괄호 ')'의 개수가

수정할 수 있는 오탈자 ')' 경우의 수가 된다. <이 문제에서도> = 2

/ 뒤에건 오탈자가 될 수 없다.

total = -1이 나오면 무조건 그 순간까지 오탈자가 있다는 뜻이고, 뒤에거는 고려x

  
예시 3.
하나의 예를 더 들겠다.

( ) ( ) ) ) -> total : +1, 0, +1, 0, -1, -2

( ) ( ) ) / ')' : +1, 0, +1, 0, -1 /

/ 요거 뒤(total=-1이 나온순간)에는 무조건 닫는괄호  ')'가 나와야한다.

즉, ( ) ( ) ) / ) 왜냐? '(' 나오면

( ) ( ) ) / '(' 오탈자 2개임.

total = -1 나온순간부터 뒤에껀 신경x

total = -1이 기준이라는게 명확해졌다. ㅋㅋㅋㅋ

그 기준점까지의 ')'의 개수가 <오탈자 ')' 수정할 수 있는 경우의 수>

이 문제에서는 <3>이다!!


예시 4.
아직, 아리까리 할 수도 있다.

마지막으로 한번만 더 간단한 예를 들겠다.

) ) -> total : -1, -2
) / ) :  -1/

')' 나오면 뒤에는 무조건 닫는괄호 ')' 나올 수 밖에 없다.

즉, total = -1 기준까지의 닫는괄호 개수가 <경우의 수>다. 이 문제에서는 <1>이다!



----------------------------------------------------------------


이제부터가 관건!! 

여는 괄호 '(' 가 오탈자이고, 수정했을 때 올바른 괄호쌍이 되는 경우를 살펴보자.

일단, 여는 괄호 '(' 가 오탈자라는 뜻은   닫는 괄호 ')'는 건드리지 않아야 한다는 것이다.

또한 여는 괄호 '(' 가 닫는 괄호 ')' 보다 많아야 여는 괄호 '(' 가 오탈자니까 최종 total값 = +2이다.

그리고, 괄호리스트가 for문 돌면서 total = -1이 나온 적 없다는 의미다.

total이 -1 나오면 닫는 괄호 ')'가 오탈자니까... <우리는 '(' 오탈자인 경우를 따진다.> 오탈자 1개라는 전제조건에 위배.

이 말은 for문 돌면서 total 값이 0이상인 정수값이 나온다는 것!!!!

두괄식으로 결론만 말하자면, 여는괄호의 기준점은 total값이 1일 때이다.


예시를 살펴보자!

처음에 여는 괄호 '(' 로 시작. 
<Because, 닫는 괄호 ')'로 시작하면 total = -1이므로 닫는괄호 ')' 가 오탈자니까>

여는 괄호 '(' 뒤에 3개의 괄호쌍 경우의 수를 따지면서 직관적 이해를 돕겠다.

[3개의 괄호쌍 경우의 수 = 2 x 2 x 2 = 8가지 를 살펴보자.]

예시 1. 
(  ㅣ  ) ) )  -> total : +1, 0, -1 / -2  : total 값 -1 존재, 고려하지x


예시 2.
(  ㅣ  ) ) (  -> total : +1, 0, -1 / 0 : total 값 -1 존재, 고려하지x


예시 3.
(  ㅣ  ) ( )  -> total : +1, 0, +1, 0 : total 값이 1이 나온 순간까지 카운트한 여는괄호 '(' 는 바꿀 수 없다.
이 예시에서는 최종 total 값이  0이라서 오탈자  ')'가 아니다.


예시 4.
(  ㅣ  ( ) )  -> total : +1, +2, +1, 0 : total값이 1넘어가면 (total>1) 바뀔 가능성 생겼다가
뒤에 total=1 나오면 그 가능성 초기화한다. 이 예시에서는 최종 total 값이 0이라서 오탈자 ')'가 아니다.


예시 5.
(  ㅣ  ( ( )  -> total : +1, +2, +3, +2 : total=1 일 때, 여는괄호 '(' 는 바꿀 수 없다. 
그러다가 total > 1 넘어가면 여는괄호 '(' 를 바꿀 가능성이 생긴다. 
이 예시에서는 total이 1인 첫 번째 여는괄호'(' 제외 나머지 2개의 여는괄호 '(' 변경가능함. <경우의 수>=2
또 이 예시에서는 for문 돌면서 total값이 -1 안나왔고, 최종 total값이 2이므로 '('가 오탈자인게 성립.


예시 6.
(  ㅣ  ( ) (  -> total : +1, +2, +1, +2 : 전제조건 한번 더 상기해보자! 오탈자 1개가 여는괄호 '(' 다.
total > 1 일 때, 여는괄호 '(' 는 수정가능성이 있다가 total값이 1이 되는 순간, 
그 순간까지의 여는괄호 '('는 변경불가하다. 즉, 그때(total=1)까지 카운트한 여는괄호'(' 개수를 초기화해준다. 

예시 6을 조금만 더 자세히 보자.
( ( ) / (  -> total : +1, +2, +1 / +2
두번째 여는괄호 '(' 는 바뀔 수 없다. 제일 마지막 여는 괄호가 오탈자라서. 오탈자가 2개가 됨.
즉, total = 1 이 되는 순간, 그 순간까지 카운트한 여는 괄호 '(' 개수 초기화한다.


예시 7.
(  ㅣ  ) ( (  -> total : +1, 0, +1, +2
total = 1 나오면 그 순간까지 나온 여는괄호 '(' 는 바꿀 수 없음. total>1 부터 변경가능한 오탈자로 카운트함.
이 예시에서 <수정가능한 여는괄호 '(' 개수> = 1


예시 8.
(  ㅣ  ( ( (  -> total : +1, +2, +3, +4


마지막 8번째 경우로 좀 더 세세하게 직관적 이해를 돕겠다.

여는괄호 '(' 가 오탈자라면 최종 total 값이 '+2'가 되야하고, total = -1이 되는 경우가 없어야 한다.

즉, for문 돌면서 total 값이 0이상인 정수가 나와야한다.

내 마음대로 이 조건을 만족하는 total 숫자를 나열해보겠다.

1 2 3 4 ㅣ 여기까지가 예시8 이다.

total : 1 2 3 4 3 4 5 6 5 4 3 2
total = 1이 되는 경우가 맨처음 말고는 없다.
처음 이후에 여는괄호 '(' 로 카운트 된 값이 수정가능한 경우의 수.

total : 1 2 3 4 3 2 3 2 1 0 1 2
total = 1이 될 때, 그 전까지 카운트 된 여는괄호 '(' 개수를 초기화시킨다. 
오탈자가 2개가 되면 안되니까..!!
마지막 total값 +2가 나온 여는괄호 '('만 변경가능한 오탈자다. <수정 가능 오탈자 경우의 수> = 1 

의식의 흐름대로 써봤습니다 ㅋㅋ 도움이 되셨길..